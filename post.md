# Real-Time Communication in ReasonML with `bs-socket`

In this post I'll demonstrate some real-time communication in a simple Application using [ReasonML](https://reasonml.github.io/).  If you're brand new to Reason, some assumed basic comfort in JavaScript should be most of what you need, and there's a handy [cheatsheet](https://reasonml.github.io/docs/en/syntax-cheatsheet) to get you started.  The only other unfamiliar element will be the `|>` pipe operator.  In brief, `a |> b` is the same as `b(a)`.  It can be much more readable when chaining multiple functions.  I'm using the [bs-socket](https://github.com/reasonml-community/bs-socket.io) bindings for [socket.io](https://socket.io/), a widely used Node.js real-time engine, and their [example](https://github.com/reasonml-community/bs-socket.io/tree/master/example) as a base.

## Requirements

This is a [Node](https://nodejs.org/en/) project.  I'll be using [yarn](https://yarnpkg.com/en/) if you'd like to follow along exactly.  All other dependencies will be handled by node.

## Setup

First install the [BuckleScript](https://bucklescript.github.io/) platform if you do not already have it have it:

```
$ yarn global add bs-platform
```

Now we can use the `bsb` build tool to create a basic project:

```
$ bsb -init reason-buttons -theme basic-reason
$ cd reason-buttons/
$ yarn start
```

This will start the compiler in watch mode - any changes you make to a file will immediately trigger a recompile of the resulting JavaScript, right next to the source.  Verify you see both `Demo.re` and `Demo.bs.js`. under `reason-buttons/src`.  Rename your Reason file to `ButtonServer.re` and see it immediately recompile to reflect the difference - `Demo.bs.js` is removed and the same contents now fill `ButtonServer.bs.js`.

Add a script to your newly generated `package.json` to execute this file:

```json
// ..
"scripts": {
  "build": "bsb -make-world",
  "serve": "node src/ButtonServer.bs.js",  // <- here
  "start": "bsb -make-world -w",
  "clean": "bsb -clean-world"
},
// ..
```

One change I always immediately make in a Node.js App is pulling the port number out.  Luckily, interop is dirt simple!  We can just use Node to grab it from an environment variable.  Create a file at `src/Extern.re` with the following contents:

```reasonml
[@bs.val] external portEnv: Js.Nullable.t(string) = "process.env.PORT";
[@bs.val] external parseInt: (string, int) => int = "parseInt";
```

The `[@bs.val]` syntax is a BuckleScript compiler directive.  There's an overview of the various syntaxes [here](https://bucklescript.github.io/docs/en/interop-cheatsheet) and the rest of that guide goes in depth about when to use each.  I won't get too far into the nuts and bolts of JS interop in this post, the docs are thorough and for the most part in find the resulting code legible.  The basic idea is that the keyword `external` is kind of like `let` except the body is a string name pointing to the external function.  This way we can incrementally strongly type the JavaScript we need and have Reason typecheck everything smoothly.

This code will also leverage the `option` [data type utilities](https://bucklescript.github.io/bucklescript/api/Belt.Option.html) for nullable values like `getWithDefault` from [`Belt`](https://bucklescript.github.io/bucklescript/api/Belt.html), the standard library that ships with Reason.  Replace the contents of `src/ButtonServer.js` with the following:

```reasonml
open Belt.Option;
open Extern;

let port = getWithDefault(portEnv |> Js.Nullable.toOption, "3000");

print_endline("Listening at *:" ++ port);
```

I like to use `3000` for my default, you're of course welcome to use whatever you like.  Over in `ButtonServer.bs.js` the compiled output is quite readable:

```javascript
// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");

var port = Belt_Option.getWithDefault((process.env.PORT == null) ? undefined : Caml_option.some(process.env.PORT), "3000");

console.log("Listening at *:" + port);

exports.port = port;
/* port Not a pure module */
```

Lets verify it works.  Open up a separate terminal and type `yarn serve`.  You should see the following:

```
$ yarn serve
yarn run v1.13.0
$ node src/ButtonServer.bs.js
Port: 3000
Done in 0.09s
$
```

## Dependencies

For an example of how to use node's `Http` module manually see [this post](https://notes.maciejsmolinski.com/2018/03/02/reasonml-http-server-in-node-js/) by Maciej Smolinski.  For simplicity's sake I'll just use the community bindings for [`bs-express`](https://github.com/reasonml-community/bs-express).  We'll also pull in `bs-socket`:

```
$ yarn add -D bs-express https://github.com/reasonml-community/bs-socket.io.git
```

Then add it to `bs-config.json`:

```json
// ..
"bs-dependencies": [
  "bs-express",
  "bs-socket"
],
// ..
```

Bucklescript will take care of the rest as long as the package in question has a `bsconfig.json`.

## Messages

Before we actually implement our server, though, we need to define some message types.  This will help us plan the scope of the application.  Create a new file at `src/Messages.re` with the following contents:

```reasonml
/* Messages */

type labelName = string;
type buttonList = list(labelName);
type numClients = int;

type msg =
  | AddButton(labelName)
  | RemoveButton(labelName);

type clientToServer =
  | Msg(msg)
  | Howdy;

type serverToClient =
  | Msg(msg)
  | ClientDelta(int)
  | Success((numClients, buttonList));
```

These are the various messages we'll be sending back and forth.  This is the biggest difference from using `socket.io` in JavaScript, where custom events are named with strings.  Here we always just emit the generic message but use pattern matching to destructure it.  The library currently doesn't cover stringly typed events, though the one issue open is [asking about it](https://github.com/reasonml-community/bs-socket.io/issues/9).  The readme on that GitHub repo puts it succinctly:  "The API differs a bit from socket.io's API to be more idiomatic in Reason. Generally, e.g. JavaScript's `socket.emit("bla", 10)` becomes `Server.emit(socket, Bla(10))` in Reason".

Take a look at `Messages.bs.js`:

```js
// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
/* This output is empty. Its source's type definitions, externals and/or unused code got optimized away. */
```

We haven't used any of these definitions yet, so they don't end up represented at all in our bundle.  Neat!

## Server

### Express

Alright - one last step before we can write our server.  Back in `src/Extern.re`, add the following typings for `Http` at the bottom of the file:

```reason
module Http = {
  type http;
  [@bs.module "http"] external create: Express.App.t => http = "Server";
  [@bs.send] external listen: (http, int, unit => unit) => unit = "";
};
```

Now we're ready!  Get back into `src/ButtonServer.re` and make it look like this:

```reason
open Belt.Option;
open Express;
open Extern;

let port = getWithDefault(portEnv |> Js.Nullable.toOption, "3000");

let app = express();

let http = Http.create(app);

Http.listen(http, port |> int_of_string, () =>
  print_endline("Listening at *:" ++ port)
);
```

Just to verify it works, add a placeholder `/` endpoint, above the `Http.listen()` line.  We'll come back to the client.

```reason
App.get(app, ~path="/") @@
Middleware.from((_, _) => Response.sendString("<h1>HELLO, REASON</h1>"));
```

Alright, I lied - there's one more bit o' syntax there.  Per [the docs](https://reasonml.github.io/api/Pervasives.html) `(@@)` is the application operator - "g @@ f @@ x is exactly equivalent to g (f (x))."  If you're familiar with Haskell, it's `($)`, or if you're familiar with...math, I guess, it's `g o f(x)`.

Let's make sure we're good to go:

```
$ yarn serve
$ node src/ButtonServer.bs.js
Listening at *:3000
```

If you point your browser, you should see **HELLO REASON**.

### Socketry

Now for the real-time bits! WRITE ONCE YOU HAVE EXAMPLE WORKING

Start with:

```reason
module Server = BsSocket.Server.Make(Messages);

let io = Server.createWithHttp(http);

Server.onConnect(
  io,
  socket => {
    open Server;
    print_endline("Client connected");
    Socket.on(
      socket,
      fun
      | Msg(msg) => {
          switch (msg) {
          | AddButton(name) => print_endline("Add " ++ name)
          | RemoveButton(name) => print_endline("Remove " ++ name)
          };
        }
      | Howdy => {
          print_endline("Well howdy back, client");
        },
    );
  },
);
```

This is a basic skeleton, now we need some state.  We've got two things to keep track of: the current list of buttons and the current connected clients.

```reason
type appState = {
  buttons: array(string),
  clients: array(BsSocket.Server.socketT),
};

let state = {buttons: [|"Click me"|], clients: [||]};
```

The app starts pre-populated with a single button.

## Client

I'd feel remiss if I didn't use the ReasonReact library for this - it's excellent.  First, add the dependencies:

```
$ yarn add react react-dom
$ yarn add -D reason-react
```

Also add `reason-react` to `bsconfig.json`:

```json
  "bs-dependencies": [
    "bs-express",
    "bs-socket",
    "reason-react"
  ],
```

While we're in here, let's activate JSX.  Add the following entry to the top level:

```json
  "reason": {
    "react-jsx": 2
  },
```

We also need a stub to mount to.  Create a file at your project root called `index.html`:
  ## NOPE PARCEL ##
```html
<!DOCTYPE html>
<html>

<head>
    <title>Reason Buttons</title>
</head>

<body>
    <div id="app"></div>
    <script src="/socket.io/socket.io.js"></script>
    <script src="./require-polyfill.js" data-main="./src/Index.bs.js" data-project-root="./"></script>
</body>

</html>
```

We also need to tell our server to serve this file instead of our placeholder string.  We'll use a little more interop from this - add the following to `Extern.re`, helpfully lifted from the [bs-socket example](https://github.com/reasonml-community/bs-socket.io/blob/master/example/ExampleServer.re):

```reason

// are we using this?!
module Path = {
  type pathT;
  [@bs.module "path"] [@bs.splice]
  external join : array(string) => string = "";
};

[@bs.val] external __dirname : string = "";
```

Now replace the endpoint in `ButtonServer.re` with:

```reason
let projectRoot = Path.join([|__dirname, ".."|]);

App.useOnPath(
  app,
  ~path=projectRoot,
  {
    let options = Static.defaultOptions();
    Static.make("static", options) |> Static.asMiddleware;
  },
);

App.get(app, ~path="/") @@
Middleware.from((_, _, res) =>
  res |> Response.sendFile("index.html", {"root": projectRoot})
);
```

We define our project root as the parent of `src/`, set up our static file serving, and serve `index.html` at `/` instead of the placeholder string.

New, create a file at `src/ButtonClient.re`

## Make it native

[A guide to native ReasonML for NodeJS developers](https://www.strv.com/blog/guide-native-reasonml)